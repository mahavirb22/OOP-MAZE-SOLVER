// Frontend JavaScript - Only handles UI and WebSocket connection
// All backend logic is handled by C++ server

const canvas = document.getElementById('mazeCanvas');
const ctx = canvas.getContext('2d');
const generateBtn = document.getElementById('generateBtn');
const solveBtn = document.getElementById('solveBtn');
const sizeInput = document.getElementById('mazeSize');
const statusDiv = document.getElementById('status');

let socket;
let currentMazeData = null;
const CELL_SIZE = 20;
let isAnimating = false;

// Connect to C++ WebSocket server
function connect() {
    socket = new WebSocket('ws://localhost:8081');

    socket.onopen = () => {
        console.log('Connected to C++ Backend Server');
        updateStatus('Connected to C++ server', 'success');
    };

    socket.onmessage = (event) => {
        try {
            currentMazeData = JSON.parse(event.data);
            drawMaze(currentMazeData);
            solveBtn.style.display = 'inline-block';
            updateStatus('Maze generated by C++! Click "Visualize A* Algorithm" to see the pathfinding.', 'success');
        } catch (e) {
            console.error("Error parsing maze data from C++ backend", e);
            updateStatus('Error generating maze', 'error');
        }
    };

    socket.onerror = () => {
        updateStatus('Connection error. Make sure C++ server is running!', 'error');
    };
}

function updateStatus(message, type) {
    if (statusDiv) {
        statusDiv.textContent = message;
        statusDiv.className = 'status show';
        statusDiv.style.background = type === 'error' ? 
            'linear-gradient(135deg, rgba(245, 87, 108, 0.1) 0%, rgba(240, 147, 251, 0.1) 100%)' :
            'linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%)';
        statusDiv.style.color = type === 'error' ? '#f5576c' : '#667eea';
    }
}

function drawMaze(data) {
    const rows = data.rows;
    const cols = data.cols;
    
    // Resize canvas
    canvas.width = cols * CELL_SIZE;
    canvas.height = rows * CELL_SIZE;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (data.grid[r][c] === 1) {
                // Wall - dark blue/gray
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            } else {
                // Path - white
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
                // Add subtle grid
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }
    }
    
    // Draw start marker (green)
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.arc(1 * CELL_SIZE + CELL_SIZE/2, 0 * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/3, 0, 2*Math.PI);
    ctx.fill();
    
    // Draw end marker (red)
    const endRow = rows - 1;
    const endCol = cols - 2;
    ctx.fillStyle = '#e74c3c';
    ctx.beginPath();
    ctx.arc(endCol * CELL_SIZE + CELL_SIZE/2, endRow * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/3, 0, 2*Math.PI);
    ctx.fill();
}

function drawCell(x, y, color, alpha = 1.0) {
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(y * CELL_SIZE + 2, x * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
    ctx.globalAlpha = 1.0;
}

async function animateExplored(explored) {
    updateStatus('A* Algorithm exploring paths...', 'info');
    
    for (let i = 0; i < explored.length; i++) {
        const cell = explored[i];
        
        // Skip start and end positions
        if ((cell.x === 0 && cell.y === 1) || 
            (cell.x === currentMazeData.rows - 1 && cell.y === currentMazeData.cols - 2)) {
            continue;
        }
        
        // Draw explored cell with gradient effect
        const progress = i / explored.length;
        const hue = 240 + (progress * 30); // Blue to purple gradient
        drawCell(cell.x, cell.y, `hsla(${hue}, 70%, 60%, 0.4)`, 0.6);
        
        // Slower animation for better visualization
        if (i % 3 === 0) {
            await new Promise(resolve => setTimeout(resolve, 20));
        }
    }
}

async function animateSolution(solution) {
    updateStatus('Shortest path found! Drawing solution...', 'success');
    
    // Draw the path with animation
    for (let i = 0; i < solution.length; i++) {
        const cell = solution[i];
        
        // Skip start and end positions
        if ((cell.x === 0 && cell.y === 1) || 
            (cell.x === currentMazeData.rows - 1 && cell.y === currentMazeData.cols - 2)) {
            continue;
        }
        
        // Draw solution cell
        drawCell(cell.x, cell.y, '#f5576c', 0.8);
        
        // Connect with line for smooth path
        if (i > 0) {
            ctx.strokeStyle = '#f5576c';
            ctx.lineWidth = CELL_SIZE / 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const prev = solution[i - 1];
            ctx.beginPath();
            ctx.moveTo(prev.y * CELL_SIZE + CELL_SIZE/2, prev.x * CELL_SIZE + CELL_SIZE/2);
            ctx.lineTo(cell.y * CELL_SIZE + CELL_SIZE/2, cell.x * CELL_SIZE + CELL_SIZE/2);
            ctx.stroke();
        }
        
        await new Promise(resolve => setTimeout(resolve, 30));
    }
    
    updateStatus(`Path found! Length: ${solution.length} cells, Explored: ${currentMazeData.explored.length} cells`, 'success');
}

async function visualizeAStar() {
    if (!currentMazeData || !currentMazeData.explored || !currentMazeData.solution) {
        updateStatus('No maze data available', 'error');
        return;
    }
    
    if (isAnimating) return;
    
    isAnimating = true;
    solveBtn.disabled = true;
    solveBtn.innerHTML = 'Animating... <span class="loading"></span>';
    
    // Log visualization start
    const startTime = Date.now();
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ 
            type: 'visualize', 
            mazeSize: currentMazeData.rows 
        }));
    }
    
    // Redraw maze to clear any previous solution
    drawMaze(currentMazeData);
    
    // Animate explored nodes
    await animateExplored(currentMazeData.explored);
    
    // Small pause
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Animate solution path
    await animateSolution(currentMazeData.solution);
    
    // Log visualization complete
    const duration = Date.now() - startTime;
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ 
            type: 'visualization_complete', 
            duration: duration 
        }));
    }
    
    isAnimating = false;
    solveBtn.disabled = false;
    solveBtn.textContent = 'Replay Animation';
}

generateBtn.addEventListener('click', () => {
    const size = parseInt(sizeInput.value);
    if (size < 5 || size > 50) {
        updateStatus('Please enter a size between 5 and 50', 'error');
        return;
    }
    
    if (socket && socket.readyState === WebSocket.OPEN) {
        // Reset animation state
        isAnimating = false;
        currentMazeData = null;
        
        // Send request to C++ backend
        socket.send(JSON.stringify({ type: 'generate', size: size }));
        solveBtn.style.display = 'none';
        solveBtn.textContent = 'âœ¨ Visualize A* Algorithm';
        updateStatus('Requesting maze from C++ backend...', 'info');
        generateBtn.innerHTML = 'ðŸ”„ Generating... <span class="loading"></span>';
        generateBtn.disabled = true;
        
        setTimeout(() => {
            generateBtn.innerHTML = 'ðŸ”„ Generate Maze';
            generateBtn.disabled = false;
        }, 1000);
    } else {
        updateStatus('Socket not connected. Is C++ server running?', 'error');
    }
});

solveBtn.addEventListener('click', () => {
    visualizeAStar();
});

// Brochure modal handlers
const infoBtn = document.getElementById('infoBtn');
const brochureOverlay = document.getElementById('brochureOverlay');
const closeBtn = document.getElementById('closeBtn');

infoBtn.addEventListener('click', () => {
    brochureOverlay.classList.add('show');
});

closeBtn.addEventListener('click', () => {
    brochureOverlay.classList.remove('show');
});

brochureOverlay.addEventListener('click', (e) => {
    if (e.target === brochureOverlay) {
        brochureOverlay.classList.remove('show');
    }
});

// Close brochure with Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && brochureOverlay.classList.contains('show')) {
        brochureOverlay.classList.remove('show');
    }
});

// Initialize connection
connect();